# 二分查找

## 二分查找分类 
> 二分查找的使用方法主要包括以下两种（也有人总结为三种，我个人偏向于使用以下两种，基本可以解决绝大部分问题）
1. `while (low <= high)`
    - 初始条件：`low = 0, high = len - 1`
    - 终止：`low > high`
    - 向左查找：`high = mid-1`
    - 向右查找：`low = mid+1`
    - **关键属性**：不需要后处理，循环结束之后，找到就是找到，没找到就是没找到
2. `while (low < high)`
    - 初始条件：`low = 0, high = len - 1`（也有`high = len`的用法）
    - 终止：`low = high`
    - 向左查找：`high = mid`
    - 向右查找：`low = mid+1` 
    - 关键属性：循环查找中至少有两个元素，循环结束之后，还剩下一个元素，需要判断是否符合条件
> - 一般情况下，因为`mid = (high - low) / 2 + low`更靠近`low`，所以一般直接修改`low = mid + 1`（向右）。而向左时，一般采用`high = mid`，不采用`high = mid - 1`，因为可能造成死循环。

> - 类似的，`mid = (high - low + 1) / 2 + low`更靠近`high`，所以一般直接修改`high = mid - 1`（向左）。这种情况下，不采用`low = mid + 1`，因为这样可能会造成死循环。 

## 问题示例
### 1. 求平方根, 第一个错误的版本，寻找比目标字母大的最小字母
``` python
while low <= high:
    if mid * mid <= x:
        ans = mid
        low = mid + 1
    else:
        high = mid + 1
```
### 2. 旋转数组
- 查找值：先判断是否全局有序（全局有序按正常的二分查找），再判断左侧是否有序(`nums[low] <= nums[mid]`)，再优先判断判断该数是否在有序的那一侧，否则就在无序的一侧。
- 查找最小值：先判断是否全局有序（`nums[low] <= nums[high]`全局有序直接`return`），左边有序（`nums[low] <= nums[mid]`）的话肯定在右边，右边有序的话（`high = mid`）
- 查找最小值，但是有重复值：先首尾去重（`nums[low]`和`nums[high]`不应该相等），其余步骤和上面一样
### 3. 寻找峰值（比较相邻元素）
- 建议使用`while (low < high)`，确保最后还剩一个元素且该元素在范围内。比较`nums[mid]` 和 `nums[mid+1]`，函数最后`return low`。
- 若使用`while (low <= high)`，则需要注意`mid + 1`是否超出索引范围，超出（说明已经找到最右边的最大值了）则直接`break`。此时需要再判断`low`是否超出索引。
### 4. 二叉搜索树，pow()实现
- 拆分两半实现，然后用递归实现
### 5. 排序数组中查找元素的第一个和最后一个位置
- 若想要在`O(nlogn)`时间复杂度内完成，需要借鉴`1`里面的方法，先找出`left`，再找出`right`。
